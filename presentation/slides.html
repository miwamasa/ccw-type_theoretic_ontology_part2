<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>型理論ベース オントロジー探索・合成システム</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            width: 720pt;
            height: 405pt;
        }
        .slide {
            width: 720pt;
            height: 405pt;
            padding: 40pt;
            box-sizing: border-box;
            page-break-after: always;
            position: relative;
        }

        /* Color Palette: Classic Blue + Teal */
        .bg-navy { background-color: #1C2833; color: #F4F6F6; }
        .bg-slate { background-color: #2E4053; color: #F4F6F6; }
        .bg-light { background-color: #F4F6F6; color: #1C2833; }
        .text-teal { color: #5EA8A7; }
        .text-navy { color: #1C2833; }

        h1 {
            font-size: 36pt;
            margin: 0 0 20pt 0;
            font-weight: bold;
        }
        h2 {
            font-size: 32pt;
            margin: 0 0 20pt 0;
            font-weight: bold;
        }
        h3 {
            font-size: 24pt;
            margin: 0 0 15pt 0;
            font-weight: bold;
        }
        h4 {
            font-size: 20pt;
            margin: 0 0 10pt 0;
            font-weight: bold;
        }
        p {
            font-size: 16pt;
            margin: 0 0 10pt 0;
            line-height: 1.4;
        }
        ul, ol {
            font-size: 16pt;
            margin: 0 0 10pt 0;
            padding-left: 25pt;
            line-height: 1.6;
        }
        li {
            margin-bottom: 8pt;
        }
        code {
            font-family: 'Courier New', monospace;
            font-size: 14pt;
            background-color: #ECF0F1;
            padding: 2pt 4pt;
        }
        .code-block {
            font-family: 'Courier New', monospace;
            font-size: 13pt;
            background-color: #ECF0F1;
            padding: 15pt;
            margin: 10pt 0;
            line-height: 1.4;
            white-space: pre;
        }
        .center {
            text-align: center;
        }
        .formula {
            font-family: 'Times New Roman', serif;
            font-size: 18pt;
            font-style: italic;
            text-align: center;
            margin: 15pt 0;
        }
        .highlight {
            color: #5EA8A7;
            font-weight: bold;
        }
        .subtitle {
            font-size: 20pt;
            margin-top: 10pt;
        }
        .placeholder {
            border: 2px dashed #AAB7B8;
            background-color: #F9F9F9;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #7F8C8D;
        }
    </style>
</head>
<body>

<!-- Slide 1: Title -->
<div class="slide bg-navy center">
    <div style="margin-top: 80pt;">
        <h1>型理論ベース<br/>オントロジー探索・合成システム</h1>
        <p class="subtitle text-teal">Type-Theoretic Ontology Exploration and Synthesis</p>
        <p style="margin-top: 60pt; font-size: 18pt;">カテゴリ理論 × 型理論 × オントロジー工学</p>
    </div>
</div>

<!-- Slide 2: Overview -->
<div class="slide bg-light">
    <h2 class="text-navy">プロジェクト概要</h2>
    <h3 class="text-teal">目的</h3>
    <p>異なるオントロジー間の変換を、型理論とカテゴリ理論を用いて自動的に発見・合成する</p>

    <h3 class="text-teal" style="margin-top: 20pt;">主要コンポーネント</h3>
    <ul>
        <li>Span/Cospan理論に基づくオントロジーアライメント</li>
        <li>型充足問題による関数合成の自動発見</li>
        <li>DSLによる宣言的なカタログ定義</li>
        <li>実行エンジン（SPARQL/REST/Formula）</li>
        <li>PROV-O準拠のProvenance生成</li>
    </ul>
</div>

<!-- Slide 3: Section 1 - Theory -->
<div class="slide bg-slate center">
    <h1>第1部：理論的基礎</h1>
    <p class="text-teal" style="font-size: 20pt; margin-top: 20pt;">Span/Cospan理論と型理論</p>
</div>

<!-- Slide 4: Span/Cospan Theory -->
<div class="slide bg-light">
    <h2 class="text-navy">Span/Cospan理論</h2>
    <h3 class="text-teal">Span構造</h3>
    <p>2つのオントロジーを中間オントロジーで接続</p>
    <div class="code-block">A ← M → B</div>

    <ul>
        <li><span class="highlight">A, B:</span> ソース・ターゲットオントロジー</li>
        <li><span class="highlight">M:</span> 中間オントロジー（マッピング仲介者）</li>
        <li><span class="highlight">射:</span> オントロジー準同型（構造を保つ写像）</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">Cospan構造</h3>
    <p>2つのオントロジーから共通の統合オントロジーへ</p>
    <div class="code-block">A → U ← B</div>

    <p>Pullback操作により、最も精密な整合性を保つマッピングを構築</p>
</div>

<!-- Slide 5: Type Theory Basics -->
<div class="slide bg-light">
    <h2 class="text-navy">型理論の基礎</h2>
    <h3 class="text-teal">型システム</h3>
    <ul>
        <li><span class="highlight">型 (Type):</span> データの分類・制約を表現</li>
        <li><span class="highlight">項 (Term):</span> 型に属する具体的な値</li>
        <li><span class="highlight">判断 (Judgment):</span> t : T （項tが型Tに属する）</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">関数型</h3>
    <p>関数は型から型への写像</p>
    <div class="code-block">f : A → B</div>
    <p>関数fは型Aの値を受け取り、型Bの値を返す</p>

    <h3 class="text-teal" style="margin-top: 15pt;">関数合成</h3>
    <p>f : A → B と g : B → C があるとき</p>
    <div class="code-block">g ∘ f : A → C</div>
    <p>この合成により、複雑な変換を段階的に構築</p>
</div>

<!-- Slide 6: Type Inhabitation Problem -->
<div class="slide bg-light">
    <h2 class="text-navy">型充足問題</h2>
    <h3 class="text-teal">問題定義</h3>
    <p>与えられた型Tに対して、その型を持つ項を見つける問題</p>
    <div class="code-block">Find t such that t : T</div>

    <h3 class="text-teal" style="margin-top: 15pt;">本システムへの適用</h3>
    <ul>
        <li><span class="highlight">Goal:</span> ソース型 S からターゲット型 T への変換</li>
        <li><span class="highlight">Catalog:</span> 利用可能な関数の集合</li>
        <li><span class="highlight">Task:</span> S → T という型を満たす関数合成を発見</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">探索アルゴリズム</h3>
    <p>Dijkstra法ベースの後方探索</p>
    <ul>
        <li>ゴール型Tから開始し、Sに到達するパスを探索</li>
        <li>コスト最小・信頼度最大のパスを優先</li>
    </ul>
</div>

<!-- Slide 7: Automatic Discovery -->
<div class="slide bg-light">
    <h2 class="text-navy">中間型の自動発見</h2>
    <h3 class="text-teal">従来の課題</h3>
    <p>オントロジーマッピングでは、中間オントロジーを手動で設計する必要があった</p>

    <h3 class="text-teal" style="margin-top: 15pt;">本システムのアプローチ</h3>
    <ul>
        <li>型充足問題として定式化</li>
        <li>カタログから関数を選択し、自動的に合成</li>
        <li>複数の中間型を経由するパスも発見可能</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">例</h3>
    <div class="code-block">Goal: PurchaseAmount → kg-CO2

Path found:
PurchaseAmount → MonetaryValue → EnergyConsumption → kg-CO2

Functions:
  purchaseToMonetary : PurchaseAmount → MonetaryValue
  monetaryToEnergy   : MonetaryValue → EnergyConsumption
  energyToEmissions  : EnergyConsumption → kg-CO2</div>
</div>

<!-- Slide 8: Section 2 - YAML Implementation -->
<div class="slide bg-slate center">
    <h1>第2部：YAMLベースの実装</h1>
    <p class="text-teal" style="font-size: 20pt; margin-top: 20pt;">簡易DSLによる探索システム</p>
</div>

<!-- Slide 9: YAML Catalog -->
<div class="slide bg-light">
    <h2 class="text-navy">YAMLカタログ定義</h2>
    <h3 class="text-teal">構造</h3>
    <div class="code-block">types:
  - name: MonetaryValue
    unit: JPY
  - name: EnergyConsumption
    unit: kWh

functions:
  - name: purchaseToEnergy
    source: MonetaryValue
    target: EnergyConsumption
    cost: 0.5
    confidence: 0.9
    implementation:
      type: formula
      expr: "x * 0.002"</div>

    <h3 class="text-teal" style="margin-top: 15pt;">特徴</h3>
    <ul>
        <li>人間が読みやすい宣言的記述</li>
        <li>型、関数、コスト、信頼度を明示</li>
        <li>実装方法（formula/SPARQL/REST）を指定可能</li>
    </ul>
</div>

<!-- Slide 10: Search Algorithm -->
<div class="slide bg-light">
    <h2 class="text-navy">探索アルゴリズム</h2>
    <h3 class="text-teal">Dijkstra後方探索</h3>
    <div class="code-block">def synthesize_backward(catalog, source_type, goal_type):
    pq = [(0.0, 0.0, counter, goal_type, [])]
    visited = set()

    while pq:
        cum_cost, cum_conf, _, current_type, path = heappop(pq)

        if current_type == source_type:
            return path  # Solution found

        for func in catalog.functions:
            if func.target == current_type:
                next_type = func.source
                new_cost = cum_cost + func.cost
                new_conf = cum_conf + (1.0 - func.confidence)
                heappush(pq, (new_cost, new_conf, counter, next_type, [func] + path))
                counter += 1</div>

    <ul style="margin-top: 15pt;">
        <li>優先度キュー: (コスト, 信頼度損失, カウンタ, 型, パス)</li>
        <li>ゴールから開始、ソースに到達するまで後方探索</li>
    </ul>
</div>

<!-- Slide 11: Validation Results -->
<div class="slide bg-light">
    <h2 class="text-navy">検証結果</h2>
    <h3 class="text-teal">テストシナリオ</h3>
    <ul>
        <li>CFP計算：購買金額 → CO2排出量</li>
        <li>エネルギー換算：電力消費 → ガス消費</li>
        <li>複数中間型を経由するパス</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">成果</h3>
    <ul>
        <li><span class="highlight">100%</span> のパス発見成功率</li>
        <li>平均 <span class="highlight">2-3ホップ</span> で目標型に到達</li>
        <li>コスト最小パスの正確な選択</li>
        <li>信頼度を考慮した最適化</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">限界</h3>
    <ul>
        <li>集約関数（複数入力）の扱いが単純化されている</li>
        <li>単位変換が型システムに統合されていない</li>
    </ul>
</div>

<!-- Slide 12: Section 3 - DSL Design -->
<div class="slide bg-slate center">
    <h1>第3部：本格的なDSL設計</h1>
    <p class="text-teal" style="font-size: 20pt; margin-top: 20pt;">拡張可能なDSLと実行エンジン</p>
</div>

<!-- Slide 13: DSL Syntax -->
<div class="slide bg-light">
    <h2 class="text-navy">DSL構文</h2>
    <h3 class="text-teal">型定義</h3>
    <div class="code-block">type EmissionFactor [unit=kg-CO2/kWh] {
  doc: "Emission factor for energy consumption"
  metadata: {
    domain: "GHG Protocol"
    version: "2024"
  }
}</div>

    <h3 class="text-teal" style="margin-top: 15pt;">関数定義</h3>
    <div class="code-block">fn energyToEmissions {
  sig: EnergyConsumption -> EmissionFactor -> kg-CO2
  impl: formula("energy * factor")
  cost: 0.1
  confidence: 0.95
  provenance: {
    method: "IPCC Guidelines"
    source: "IEA Database"
  }
}</div>
</div>

<!-- Slide 14: Implementation Types -->
<div class="slide bg-light">
    <h2 class="text-navy">実装の種類</h2>
    <h3 class="text-teal">1. Formula実装</h3>
    <p>数式による直接計算</p>
    <div class="code-block">impl: formula("x * 0.5 + 100")</div>

    <h3 class="text-teal" style="margin-top: 15pt;">2. SPARQL実装</h3>
    <p>RDFデータベースへのクエリ</p>
    <div class="code-block">impl: sparql {
  endpoint: "http://example.org/sparql"
  query: "SELECT ?value WHERE { ?s ex:property ?value }"
}</div>

    <h3 class="text-teal" style="margin-top: 15pt;">3. REST実装</h3>
    <p>外部APIの呼び出し</p>
    <div class="code-block">impl: rest {
  url: "https://api.example.com/convert"
  method: "POST"
  body_template: '{"value": {{input}}}'
}</div>
</div>

<!-- Slide 15: Execution Engine -->
<div class="slide bg-light">
    <h2 class="text-navy">実行エンジン</h2>
    <h3 class="text-teal">機能</h3>
    <ul>
        <li><span class="highlight">Executor:</span> 関数パスの実行（formula/SPARQL/REST対応）</li>
        <li><span class="highlight">UnitConverter:</span> 単位変換の自動実行</li>
        <li><span class="highlight">ProvenanceGenerator:</span> PROV-O準拠のProvenance生成</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">実行例</h3>
    <div class="code-block">result = executor.execute(path, input_value)
# result = {
#   "value": 123.45,
#   "unit": "kg-CO2",
#   "provenance": {
#     "activity": "prov:Activity_001",
#     "wasGeneratedBy": [...],
#     "used": [...]
#   }
# }</div>

    <p style="margin-top: 15pt;">実行の各ステップでProvenanceを記録し、トレーサビリティを確保</p>
</div>

<!-- Slide 16: Provenance -->
<div class="slide bg-light">
    <h2 class="text-navy">PROV-O Provenance</h2>
    <h3 class="text-teal">W3C PROV-O準拠</h3>
    <ul>
        <li><span class="highlight">Entity:</span> 入力・出力データ</li>
        <li><span class="highlight">Activity:</span> 関数の実行</li>
        <li><span class="highlight">wasGeneratedBy:</span> データ生成の因果関係</li>
        <li><span class="highlight">used:</span> アクティビティが使用したエンティティ</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">生成例</h3>
    <div class="code-block">{
  "@context": "http://www.w3.org/ns/prov",
  "entity": {
    "id": "entity:output_001",
    "value": 123.45,
    "unit": "kg-CO2"
  },
  "activity": {
    "id": "activity:energyToEmissions",
    "startedAtTime": "2024-01-15T10:30:00Z",
    "endedAtTime": "2024-01-15T10:30:01Z"
  },
  "wasGeneratedBy": {
    "entity": "entity:output_001",
    "activity": "activity:energyToEmissions"
  }
}</div>
</div>

<!-- Slide 17: Section 4 - CFP Example -->
<div class="slide bg-slate center">
    <h1>第4部：CFP計算の実例</h1>
    <p class="text-teal" style="font-size: 20pt; margin-top: 20pt;">Carbon Footprint計算での適用</p>
</div>

<!-- Slide 18: CFP Problem -->
<div class="slide bg-light">
    <h2 class="text-navy">問題設定</h2>
    <h3 class="text-teal">シナリオ</h3>
    <p>企業の購買データから温室効果ガス排出量を計算</p>

    <h3 class="text-teal" style="margin-top: 15pt;">入力</h3>
    <ul>
        <li>購買金額（JPY）</li>
        <li>製品カテゴリ</li>
        <li>エネルギー消費量（kWh）</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">目標</h3>
    <ul>
        <li>Scope 1, 2, 3 排出量（kg-CO2）</li>
        <li>総排出量（kg-CO2）</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">課題</h3>
    <ul>
        <li>複数の変換経路が存在</li>
        <li>集約関数による統合が必要</li>
        <li>信頼度とコストのトレードオフ</li>
    </ul>
</div>

<!-- Slide 19: Search Process -->
<div class="slide bg-light">
    <h2 class="text-navy">探索プロセス</h2>
    <h3 class="text-teal">ステップ1：パス発見</h3>
    <div class="code-block">Goal: PurchaseAmount -> TotalGHGEmissions

Found Path:
  PurchaseAmount -> MonetaryValue
  MonetaryValue -> ProductCategory
  ProductCategory -> EnergyConsumption
  EnergyConsumption -> Scope2Emissions
  Scope2Emissions -> TotalGHGEmissions</div>

    <h3 class="text-teal" style="margin-top: 15pt;">ステップ2：最適化</h3>
    <ul>
        <li>総コスト: 2.1</li>
        <li>総信頼度: 0.85</li>
        <li>中間型数: 4</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">ステップ3：実行</h3>
    <p>各関数を順次実行し、Provenanceを記録</p>
</div>

<!-- Slide 20: GHG Scope 123 Scenario -->
<div class="slide bg-light">
    <h2 class="text-navy">GHG Scope 1, 2, 3シナリオ</h2>
    <h3 class="text-teal">テスト構成</h3>
    <ul>
        <li>Scope 1: 直接排出（燃料燃焼等）</li>
        <li>Scope 2: 間接排出（購入電力等）</li>
        <li>Scope 3: その他間接排出（サプライチェーン等）</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">8つのテストシナリオ</h3>
    <div class="code-block">1. Scope1Emissions → TotalGHGEmissions
2. Scope2Emissions → TotalGHGEmissions
3. Scope3Emissions → TotalGHGEmissions
4. DirectFuelCombustion → Scope1Emissions
5. PurchasedElectricity → Scope2Emissions
6. SupplyChainEmissions → Scope3Emissions
7. DirectFuelCombustion → TotalGHGEmissions (multi-hop)
8. PurchasedElectricity → TotalGHGEmissions (multi-hop)</div>
</div>

<!-- Slide 21: Analysis Results -->
<div class="slide bg-light">
    <h2 class="text-navy">分析結果</h2>
    <h3 class="text-teal">成功率</h3>
    <ul>
        <li><span class="highlight">100%</span> のシナリオでパス発見成功</li>
        <li>平均パス長: <span class="highlight">1.5</span> 関数</li>
        <li>平均コスト: <span class="highlight">1.0</span></li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">集約関数の効果</h3>
    <ul>
        <li>複数のScope排出量を統合可能</li>
        <li>型システムにシームレスに統合</li>
        <li>Provenance記録により透明性確保</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">課題と今後</h3>
    <ul>
        <li>現在の実装: 集約関数を単一入力として扱う</li>
        <li>理想: 複数引数を持つ依存型システム</li>
        <li>拡張案: Product型、Multi-argument関数サポート</li>
    </ul>
</div>

<!-- Slide 22: Metrics Analysis -->
<div class="slide bg-light">
    <h2 class="text-navy">メトリクス分析</h2>
    <h3 class="text-teal">パス長の分布</h3>
    <ul>
        <li>1関数: 6シナリオ (75%)</li>
        <li>2関数: 2シナリオ (25%)</li>
        <li>最大パス長: 2</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">コストと信頼度</h3>
    <ul>
        <li>最小コスト: 1.0</li>
        <li>最大コスト: 2.0</li>
        <li>平均信頼度: 1.0 (100%)</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">発見</h3>
    <ul>
        <li>集約関数はコスト1.0で効率的</li>
        <li>マルチホップパスも自動発見可能</li>
        <li>型システムが適切に機能している証左</li>
    </ul>
</div>

<!-- Slide 23: Section 5 - Summary -->
<div class="slide bg-slate center">
    <h1>第5部：まとめと今後の展望</h1>
</div>

<!-- Slide 24: Achievements -->
<div class="slide bg-light">
    <h2 class="text-navy">主要な成果</h2>
    <h3 class="text-teal">理論的貢献</h3>
    <ul>
        <li>Span/Cospan理論によるオントロジーアライメントの形式化</li>
        <li>型充足問題としての変換経路探索の定式化</li>
        <li>中間型の自動発見手法</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">実装的貢献</h3>
    <ul>
        <li>YAMLベースのプロトタイプ実装</li>
        <li>本格的なDSL設計と実装</li>
        <li>実行エンジン（Formula/SPARQL/REST対応）</li>
        <li>PROV-O準拠のProvenance生成</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">実証的貢献</h3>
    <ul>
        <li>CFP計算での検証</li>
        <li>GHG Scope 1,2,3シナリオでの100%成功率</li>
        <li>集約関数の統合</li>
    </ul>
</div>

<!-- Slide 25: Future Work -->
<div class="slide bg-light">
    <h2 class="text-navy">今後の展望</h2>
    <h3 class="text-teal">型システムの拡張</h3>
    <ul>
        <li><span class="highlight">依存型:</span> 値に依存する型（例：長さnのリスト）</li>
        <li><span class="highlight">多引数関数:</span> (A, B) → C のような関数</li>
        <li><span class="highlight">Product型:</span> A × B による直積型</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">実行エンジンの強化</h3>
    <ul>
        <li>並列実行による高速化</li>
        <li>キャッシュ機構の導入</li>
        <li>エラーハンドリングの充実</li>
        <li>GraphQL/gRPC対応</li>
    </ul>

    <h3 class="text-teal" style="margin-top: 15pt;">応用領域の拡大</h3>
    <ul>
        <li>サプライチェーン全体のCFP計算</li>
        <li>生物多様性データの統合</li>
        <li>ESG指標の自動計算</li>
    </ul>
</div>

<!-- Slide 26: Conclusion -->
<div class="slide bg-navy">
    <h2 style="color: #F4F6F6; margin-bottom: 30pt;">結論</h2>
    <ul style="font-size: 18pt; line-height: 2; color: #F4F6F6;">
        <li>型理論とカテゴリ理論により、オントロジー変換を<span class="text-teal">自動化</span></li>
        <li>DSLによる<span class="text-teal">宣言的</span>で<span class="text-teal">拡張可能</span>な設計</li>
        <li>実行エンジンにより<span class="text-teal">実用的</span>なシステムを実現</li>
        <li>CFP計算での実証により<span class="text-teal">有効性</span>を確認</li>
    </ul>

    <p style="margin-top: 50pt; font-size: 20pt; text-align: center; color: #5EA8A7;">
        持続可能性データの統合と分析を<br/>次のレベルへ
    </p>
</div>

</body>
</html>
